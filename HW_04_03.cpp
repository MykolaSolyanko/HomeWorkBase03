#include <cstring>
#include <iostream>
#include <random>

static constexpr size_t MSG_SIZE{1024};

struct data_t {
  size_t size;
  char data[MSG_SIZE];
};

struct crypto_t {
  size_t col;
  size_t row;
};

static crypto_t Alisa_crypto{};
static data_t Alisa_enc_message{};

const char *Message{"The first half of life consists of the capacity to "
                    "enjoy without the chance, the last half consists of "
                    "the chance without the capacity. Mark Twain"};

static crypto_t Bob_crypto{};
static data_t Bob_enc_message{};
static char Bob_dec_message[MSG_SIZE]{};

static void crypto_print(const char *data, crypto_t crypto) {
  std::cout << __PRETTY_FUNCTION__ << std::endl;
  for (size_t iRow = 0; iRow < crypto.row; iRow++) {
    std::cout << "ROW: " << iRow << " ";
    for (size_t iCol = 0; iCol < crypto.col; iCol++) {
      std::cout << *(data + iRow * crypto.col + iCol) << '\t';
    }
    std::cout << std::endl;
  }
}

static void crypto_write_cols(data_t *dstr, const crypto_t crypto,
                              const char *src) {
  if ((dstr == nullptr) || (src == nullptr)) {
    std::cout << "ERROR: " << __PRETTY_FUNCTION__ << std::endl;
    return;
  }
  dstr->size = 0;
  for (size_t iCol = 0; iCol < crypto.col; iCol++) {
    for (size_t iRow = 0; iRow < crypto.row; iRow++) {
      *(dstr->data + iRow * crypto.col + iCol) = *src;
      if (*src == '\0') {
        return;
      }
      src++;
      dstr->size++;
    }
  }
}

static void crypto_read_cols(const data_t *src, const crypto_t crypto,
                             char *dstr) {
  if ((dstr == nullptr) || (src == nullptr) ||
      (src->size != (crypto.row * crypto.col))) {
    std::cout << "ERROR: " << __PRETTY_FUNCTION__ << std::endl;
    return;
  }
  size_t index{};
  for (size_t iCol = 0; iCol < crypto.col; iCol++) {
    for (size_t iRow = 0; iRow < crypto.row; iRow++) {
      // if (*(src + iRow * crypto.row + iCol) == '\0') {
      //   return;
      // }
      dstr[index++] = *(src->data + iRow * crypto.col + iCol);
    }
  }
  std::cout << std::endl;
}

static size_t msg_len(const char *msg) {
  size_t len{};
  while ((msg != nullptr) && (*msg != '\0')) {
    len++;
    msg++;
  }
  return len;
}

static uint32_t rand_uint32(uint32_t MIN, uint32_t MAX) {
  // Will be used to obtain a seed for the random number engine
  std::random_device rd;
  std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
  std::uniform_int_distribution<uint32_t> distrib(MIN, MAX);
  // Use `distrib` to transform the random unsigned int generated by gen into
  // an int in [MIN, MAX]
  return distrib(gen);
}

static size_t best_devider(size_t value) {
  auto devider{value};
  while ((devider != 1) && (value % (--devider))) {
  }
  return devider;
}

static size_t devider_quantity(size_t value) {
  size_t quantity{1};
  while ((value = best_devider(value)) != 1) {
    std::cout << "Devider is: " << value << std::endl;
    quantity++;
  }
  return quantity;
}

static void ALISA_crypto_key_encode(crypto_t *crypto, const char *message) {
  if ((crypto == nullptr) || (message == nullptr)) {
    return;
  }
  auto len{msg_len(message)};
  crypto->col = len;
  for (size_t rand_x = rand_uint32(1, devider_quantity(crypto->col)); rand_x;
       rand_x--) {
    crypto->col = best_devider(crypto->col);
  }
  crypto->row = len / crypto->col;
  std::cout << __PRETTY_FUNCTION__ << std::endl;
  std::cout << "Message len = " << len << std::endl;
  std::cout << "col = " << crypto->col << std::endl;
  std::cout << "row = " << crypto->row << std::endl;
}

static void ALISA_Encode(data_t *enc_data, const crypto_t crypto,
                         const char *message) {
  if ((enc_data == nullptr) || (message == nullptr)) {
    return;
  }
  crypto_write_cols(enc_data, crypto, message);
}

static void BOB_crypto_key_decode(crypto_t *crypto,
                                  const data_t *encoded_data) {
  if ((crypto == nullptr) || (encoded_data == nullptr) ||
      (encoded_data->size != sizeof(crypto_t))) {
    return;
  }
  *crypto = *((crypto_t *)encoded_data->data);
}

static void BOB_Decode(const data_t *enc_data, const crypto_t crypto,
                       char *message) {
  if ((enc_data == nullptr) || (message == nullptr) ||
      (enc_data->size != (crypto.col * crypto.row))) {
    return;
  }
  crypto_read_cols(enc_data, crypto, message);
}

int main() {
  ALISA_crypto_key_encode(&Alisa_crypto, Message);

  Alisa_enc_message.size = sizeof(Alisa_crypto);
  memcpy(Alisa_enc_message.data, &Alisa_crypto, Alisa_enc_message.size);

  Bob_enc_message.size = Alisa_enc_message.size;
  memcpy(Bob_enc_message.data, Alisa_enc_message.data, Alisa_enc_message.size);

  BOB_crypto_key_decode(&Bob_crypto, &Bob_enc_message);

  ALISA_Encode(&Alisa_enc_message, Alisa_crypto, Message);

  crypto_print(Alisa_enc_message.data, Alisa_crypto);

  Bob_enc_message.size = Alisa_enc_message.size;
  std::cout << "Bob size: " << Bob_enc_message.size << std::endl;
  memcpy(Bob_enc_message.data, Alisa_enc_message.data, Alisa_enc_message.size);

  BOB_Decode(&Bob_enc_message, Bob_crypto, Bob_dec_message);
  std::cout << "Decoded message is: " << Bob_dec_message << std::endl;
  return EXIT_SUCCESS;
}
